{"version":3,"sources":["../../src/lib/utils.ts","../../src/lib/meta-data.ts","../../src/lib/ng-event-bus.ts"],"names":["Utils","uuid","replace","c","r","Math","random","toString","MetaData","key","data","this","_id","_key","_data","_timestamp","Date","getTime","Object","defineProperty","prototype","NgEventBus","separator","eventBus","Subject","keyMatch","wildcard","wl","k","sep","kArr","split","wArr","kLen","length","wLen","max","i","cK","cW","cast","trim","Error","metadata","next","on","_this","asObservable","pipe","filter","event","map"],"mappings":"oWASA,IAAAA,EAAA,WAAA,SAAAA,YAOgBA,EAAAC,KAAP,WACL,MAAO,uCAAuCC,QAAQ,SAAS,SAACC,GAC9D,IAAMC,EAAqB,GAAhBC,KAAKC,SAAiB,EAEjC,OADgB,MAANH,EAAYC,EAAS,EAAJA,EAAW,GAC7BG,SAAS,UAXxB,GCCAC,EAAA,WA+BE,SAAAA,EAAYC,EAAaC,GACvBC,KAAKC,IAAMZ,EAAMC,OACjBU,KAAKE,KAAOJ,EACZE,KAAKG,MAAQJ,EACbC,KAAKI,YAAa,IAAIC,MAAOC,iBAM/BC,OAAAC,eAAWX,EAAAY,UAAA,KAAE,KAAb,WACE,OAAOT,KAAKC,qCAMdM,OAAAC,eAAWX,EAAAY,UAAA,MAAG,KAAd,WACE,OAAOT,KAAKE,sCAMdK,OAAAC,eAAWX,EAAAY,UAAA,OAAI,KAAf,WACE,OAAOT,KAAKG,uCAMdI,OAAAC,eAAWX,EAAAY,UAAA,YAAS,KAApB,WACE,OAAOT,KAAKI,8CA/DhB,gBCiBE,SAAAM,IALQV,KAAAW,UAAY,IAMlBX,KAAKY,SAAW,IAAIC,EAAAA,eAWfH,EAAAD,UAAAK,SAAA,SAAShB,EAAaiB,GAgB3B,IAfA,IAGmBC,EAAYC,EAIzBC,EAAMlB,KAAKW,UACXQ,EAAOrB,EAAIsB,MAAMF,GACjBG,EAAON,EAASK,MAAMF,GAEtBI,EAAOH,EAAKI,OACZC,EAAOH,EAAKE,OACZE,EAAM/B,KAAK+B,IAAIH,EAAME,GAElBE,EAAI,EAAGA,EAAID,EAAKC,IAAK,CAC5B,IAAMC,EAAKR,EAAKO,GACVE,EAAKP,EAAKK,GAEhB,GAlBS,OAkBLE,QAA2B,IAAPD,EACtB,OAAO,EAGT,GApB6BV,EAoBVU,EAvBX,OAGSX,EAoBFY,IAnBIZ,IAAOC,EAoBxB,OAAO,EAIX,OAAO,GAUFP,EAAAD,UAAAoB,KAAA,SAAK/B,EAAaC,GACvB,IAAKD,EAAIgC,OAAOP,OACd,MAAM,IAAIQ,MAAM,wDAGlB,IAAMC,EAAqB,IAAInC,EAASC,EAAKC,GAE7CC,KAAKY,SAASqB,KAAK,CAAEnC,IAAGA,EAAEC,KAAIA,EAAEiC,SAAQA,KAUnCtB,EAAAD,UAAAyB,GAAA,SAAMpC,GAAN,IAAAqC,EAAAnC,KACL,OAAOA,KAAKY,SAASwB,eAAeC,KAClCC,EAAAA,QAAO,SAACC,GAA4B,OAAAJ,EAAKrB,SAASyB,EAAMzC,IAAKA,MAC7D0C,EAAAA,KAAI,SAACD,GAA4B,OAAAA,EAAMP","sourcesContent":["/* tslint:disable:variable-name no-bitwise */\n\n/**\n * Utilitary class.\n *\n * @author Cristiam Mercado\n * @since 2.0.0\n * @version 2.0.0\n */\nexport class Utils {\n  /**\n   * Generates UUID version 4. The solution above uses Math.random() for brevity, however Math.random() is not\n   * guaranteed to be a high-quality RNG.\n   *\n   * @return UUID version 4.\n   */\n  public static uuid(): string {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c: string) => {\n      const r = (Math.random() * 16) | 0;\n      const v = c === 'x' ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  }\n}\n","/* tslint:disable:variable-name */\nimport { Utils } from './utils';\n\n/**\n * Metadata of the messages sent through the events bus.\n *\n * @author Cristiam Mercado\n * @since 2.0.0\n * @version 2.0.0\n */\nexport class MetaData {\n  /**\n   * A unique identifier of the message sent through the events bus.\n   * @private\n   */\n  private readonly _id: string;\n\n  /**\n   * Original key associated to the message.\n   * @private\n   */\n  private readonly _key: string;\n\n  /**\n   * Data associated to message. It's optional.\n   * @private\n   */\n  private readonly _data: any;\n\n  /**\n   * Time in milliseconds in which the message was generated.\n   * @private\n   */\n  private readonly _timestamp: number;\n\n  /**\n   * Constructor for this class.\n   *\n   * @param key Original key associated to the message sent through the events bus.\n   * @param [data] Optional: Additional data sent with the message.\n   */\n  constructor(key: string, data?: any) {\n    this._id = Utils.uuid();\n    this._key = key;\n    this._data = data;\n    this._timestamp = new Date().getTime();\n  }\n\n  /**\n   * Gets unique identifier of the message sent through the events bus.\n   */\n  public get id(): string {\n    return this._id;\n  }\n\n  /**\n   * Original key associated to the message.\n   */\n  public get key(): string {\n    return this._key;\n  }\n\n  /**\n   * Data associated to message. It's optional.\n   */\n  public get data(): any {\n    return this._data;\n  }\n\n  /**\n   * Gets the time in milliseconds in which the message was generated.\n   */\n  public get timestamp(): number {\n    return this._timestamp;\n  }\n}\n","import { Observable, Subject } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\nimport { IEventBusMessage } from './i-event-bus-message';\nimport { MetaData } from './meta-data';\n\n/**\n * Main library class.\n *\n * @author Cristiam Mercado\n * @since 2.0.0\n * @version 2.0.0\n */\nexport class NgEventBus {\n  /**\n   * Main observable to multicast to all observers.\n   */\n  private eventBus: Subject<IEventBusMessage>;\n\n  /**\n   * Key message separator.\n   */\n  private separator = ':';\n\n  /**\n   * Constructor for this class: Initializes event bus.\n   */\n  constructor() {\n    this.eventBus = new Subject<IEventBusMessage>();\n  }\n\n  /**\n   * Validates key matching.\n   *\n   * @param  key Key to identify the message/event.\n   * @param wildcard Wildcard received from on method.\n   *\n   * @return true if key matches, false otherwise.\n   */\n  public keyMatch(key: string, wildcard: string): boolean {\n    const w = '*';\n    const ww = '**';\n\n    const partMatch = (wl: string, k: string): boolean => {\n      return wl === w || wl === k;\n    };\n\n    const sep = this.separator;\n    const kArr = key.split(sep);\n    const wArr = wildcard.split(sep);\n\n    const kLen = kArr.length;\n    const wLen = wArr.length;\n    const max = Math.max(kLen, wLen);\n\n    for (let i = 0; i < max; i++) {\n      const cK = kArr[i];\n      const cW = wArr[i];\n\n      if (cW === ww && typeof cK !== 'undefined') {\n        return true;\n      }\n\n      if (!partMatch(cW, cK)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Publish a message/event to event bus.\n   *\n   * @param  key Key to identify the message/event.\n   * @param  [data] Optional: Additional data sent with the message/event.\n   * @throws {Error} key parameter must be a string and must not be empty.\n   */\n  public cast(key: string, data?: any): void {\n    if (!key.trim().length) {\n      throw new Error('key parameter must be a string and must not be empty');\n    }\n\n    const metadata: MetaData = new MetaData(key, data);\n\n    this.eventBus.next({ key, data, metadata });\n  }\n\n  /**\n   * Returns an observable you can subscribe to listen messages/events.\n   *\n   * @param key Key to identify the message/event.\n   *\n   * @return Observable you can subscribe to listen messages/events.\n   */\n  public on<T>(key: string): Observable<MetaData> {\n    return this.eventBus.asObservable().pipe(\n      filter((event: IEventBusMessage) => this.keyMatch(event.key, key)),\n      map((event: IEventBusMessage) => event.metadata)\n    );\n  }\n}\n"]}